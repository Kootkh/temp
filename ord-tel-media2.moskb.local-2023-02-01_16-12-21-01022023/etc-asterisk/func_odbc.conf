;
; func_odbc.conf
;
; Each context is a separately defined function.  By convention, all
; functions are entirely uppercase, so the defined contexts should also
; be all-uppercase, but there is nothing that enforces this.  All functions
; are case-sensitive, however.
;
; For substitution, you have ${ARG1}, ${ARG2} ... ${ARGn}
; for the arguments to each SQL statement.
;
; In addition, for write statements, you have ${VAL1}, ${VAL2} ... ${VALn}
; parsed, just like arguments, for the values.  In addition, if you want the
; whole value, never mind the parsing, you can get that with ${VALUE}.
;
;
; If you have data which may potentially contain single ticks, you may wish
; to use the dialplan function SQL_ESC() to escape the data prior to its
; inclusion in the SQL statement.
;
;
; The following options are available in this configuration file:
;
; readhandle   A comma-separated list of DSNs (from res_odbc.conf) to use when
;              executing the readsql statement.  Each DSN is tried, in
;              succession, until the statement succeeds.  You may specify up to
;              5 DSNs per function class.  If not specified, it will default to
;              the value of writehandle or dsn, if specified.
; writehandle  A comma-separated list of DSNs (from res_odbc.conf) to use when
;              executing the writesql statement.  The same rules apply as to
;              readhandle.  "dsn" is a synonym for "writehandle".
; readsql      The statement to execute when reading from the function class.
; writesql     The statement to execute when writing to the function class.
; prefix       Normally, all function classes are prefixed with "ODBC" to keep
;              them uniquely named.  You may choose to change this prefix, which
;              may be useful to segregate a collection of certain function
;              classes from others.
; escapecommas This option may be used to turn off the default behavior of
;              escaping commas which occur within a field.  If commas are
;              escaped (the default behavior), then fields containing commas
;              will be treated as a single value when assigning to ARRAY() or
;              HASH().  If commas are not escaped, then values will be separated
;              at the comma within fields.  Please note that turning this option
;              off is incompatible with the functionality of HASH().
; synopsis     Appears in the synopsis field for the command
;              'core show function <function name>'
; mode         This option may be set to 'multirow' to allow the function
;              specified to return more than a single row.  However, this
;              changes the way that func_odbc normally works.  Instead of the
;              invocation of the function returning a row, it returns an opaque
;              ID, which may be passed to ODBC_FETCH() to return each row in
;              turn.  ODBC_FETCH_STATUS returns SUCCESS or FAILURE, to indicate
;              whether any results were stored, and you should call ODBC_Finish
;              on the ID to clean up any remaining results when you are done
;              with the query.  Also, the variable ODBCROWS is set initially,
;              which may be used in an iterative fashion to return each row in
;              the result.
;              Please note that multirow queries are isolated to the channel,
;              and rows may not be fetched outside of the channel where the
;              query was initially performed.  Additionally, as the results are
;              associated with a channel, mode=multirow is incompatible with
;              the global space.
; rowlimit     An additional option for within mode=multirow, rowlimit limits
;              the total number of rows which can be stored for that query.
;              Otherwise, func_odbc will attempt to store all rows in the
;              resultset, up to the maximum amount of memory.


; ODBC_SQL - Allow an SQL statement to be built entirely in the dialplan
[SQL]
; Broken in 1.6.1.9 !!!
dsn=pbx
readsql=${ARG1}
writesql=${VAL1}

[SCHEDULE]
dsn=pbx
synopsis=True if mentioned Schedule suits current time
readsql=SELECT "InSchedule"('${SQL_ESC(${ARG1})}');

[ACLCHECK]
dsn=pbx
synopsis=True if specified ACL is covering specified number, first argument is ACL, second is number
readsql=SELECT acl_check('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}');

[SIPRT]
dsn=pbx
synopsis=retrive sip-settings for sip-peer from realtime sip table
readsql=SELECT * from sip where name='${SQL_ESC(${ARG1})}';





;[NAT]
;dsn=pbx
;synopsis="NAT" implementation
;readsql=SELECT * from "NATrule"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}');
;writesql=insert into "NAT"("Line","BIND","CID","DNID","Valid") values ('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}','${SQL_ESC(${ARG4})}','${SQL_ESC(${VAL1})}');

; Dynamic sort on CallList
[SORT_CALLS]
dsn=pbx
mode=multirow
rowlimit=100
synopsis=Dynamic sort on "Calls"(SORT_NAME,CallList)  WRITE(SORT_NAME,Calls.NRec)
readsql=SELECT "Calls"."NRec","Calls"."Exten","Calls"."Type","Calls"."Order" from "Calls" left outer join "DynamicSort" on ("Calls"."NRec" = "DynamicSort"."NRec" and "DynamicSort"."List" = '${SQL_ESC(${ARG1})}') where "Calls"."CallList" = '${SQL_ESC(${ARG2})}' order by "DynamicSort"."Order", "Calls"."Order";
writesql=select "DynamicSortUp"('${SQL_ESC(${ARG1})}','${SQL_ESC(${VAL1})}');

; Duty agents
[DUTY]
dsn=pbx
synopsis=DUTY: Get settings
readsql=select "Exten","BIND","Amount","Announce" from "Duty" where "NRec" = '${SQL_ESC(${ARG1})}';

[DUTY_AGENT]
dsn=pbx
synopsis=DUTY: Validate agent; Set (Active,Fail)
readsql=select "Agent","Exten","BIND","Timeout","Announce" from "DutyAgent" join "Duty" on ("DutyAgent"."Duty" = "Duty"."NRec") where ("DutyAgent"."NRec" = '${SQL_ESC(${ARG1})}')
writesql=update "DutyAgent" SET "Active" = (CASE '${SQL_ESC(${VAL1})}' WHEN '1' then 'now' else "Active" END)::timestamp, "Called" = now(), "Fail" = (CASE '${SQL_ESC(${VAL2})}' WHEN '1' then 'now' else "Fail" END)::timestamp where ("DutyAgent"."NRec" = '${SQL_ESC(${ARG1})}')

[DUTY_AGENTS]
; Retrieve ALL agents in order of validation, as validation may stale for some reason
dsn=pbx
mode=multirow
rowlimit=100
synopsis=DUTY: Retrieve ALL agents in order of validation
readsql=select "Agent","DutyAgent"."Description", ("Active" > (now() - "Valid")) as "VALID", "Active" from  "DutyAgent" join "Duty" on ("DutyAgent"."Duty" = "Duty"."NRec") where ("Duty" = '${SQL_ESC(${ARG1})}') and ("Fail" < (now() - "Penalty")) order by "Active" DESC, "Called" ASC

; "Black list" functionality
[BL]
dsn=pbx
synopsis=select BlackLlist(CID,BIND,interval,LineRegExp) or  insert BlackList(Line,BIND,CID)
readsql=select coalesce(0, (select count("CID") from "BlackList" where ("CID" = '${SQL_ESC(${ARG1})}') and (("BIND"='${SQL_ESC(${ARG2})}') or ("BIND" is NULL) or ('${SQL_ESC(${ARG2})}'='')) and ("DT" > now() - coalesce(nullif('${SQL_ESC(${ARG3})}',''),'1 day')::interval) and ("Line" ~ '${SQL_ESC(${ARG4})}') GROUP BY "BIND" ORDER BY "BIND" DESC LIMIT 1))
writesql=insert into "BlackList" ("Line","BIND","CID","Description") values ('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${VAL1})}','${SQL_ESC(${VAL2})}')

; LINE_STATUS
[LINE_STATUS]
dsn=pbx
synopsis=Select|update line status (last ${DIALSTATUS} of ext.)
readsql=select "LineStatus"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}') LIMIT 1
writesql=insert into "LineStatus" ("Line","BIND","Status") values ('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${VAL1})}')

; Retrieve a set of routes to place outcoming call, together with src|dst mangling
[GET_CALL_ROUTES]
dsn=pbx
mode=multirow
rowlimit=100
synopsis=select * from "GetCallRoutes"("dnid" text, "cid" text default NULL, "Level" smallint default 0, "TAG" text default NULL,"BIND" text default NULL,"RDN" text default NULL)
readsql=select * from "GetCallRoutes" ('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}','${SQL_ESC(${ARG4})}','${SQL_ESC(${ARG5})}','${SQL_ESC(${ARG6})}','${SQL_ESC(${ARG6})}')

[GET_IAX_CALL_ROUTES]
dsn=pbx
mode=multirow
rowlimit=100
synopsis=select * from "GetIAXCallRoutes"("dnid" text, "cid" text default NULL, "Level" smallint default 0, "TAG" text default NULL,"BIND" text default NULL,"RDN" text default NULL, "RouteGroup" text default NULL)
readsql=select * from "GetIAXCallRoutes" ('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}','${SQL_ESC(${ARG4})}','${SQL_ESC(${ARG5})}','${SQL_ESC(${ARG6})}','${SQL_ESC(${ARG7})}')


[LEVEL]
dsn=pbx
synopsis=select * from "CallLevel"("dnid" text, "cid" text default NULL, "bind" text default '')
readsql=select "CallLevel"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}') LIMIT 1

[LEVEL_E]
; Set(HASH(CallLevel)=${ODBC_LEVEL_E(${dnid},${cid},${Aliased})});
dsn=pbx
synopsis=select * from "CallLevelE"("DNID" text, "cid" text default NULL, "Aliased" text default '')
;escapecommas=off
readsql=select * from "CallLevelE"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}','${SQL_ESC(${ARG4})}') LIMIT 1
;readsql=select * from "CallLevelERhombus"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}','${SQL_ESC(${ARG4})}') LIMIT 1
;readsql=select * from "NewCallLevelE"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}','${SQL_ESC(${ARG4})}') LIMIT 1
;readsql=select * from "NewCallLevelE7"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}','${SQL_ESC(${ARG4})}') LIMIT 1

[LEVEL_I]
; Set(HASH(CallLevel)=${ODBC_LEVEL_I(${dnid},${cid})});
dsn=pbx
synopsis=select * from "CallLevelI"("DNID" text, "cid" text default NULL)
;escapecommas=off
readsql=select * from "CallLevelI"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}') LIMIT 1

[GET_ACTION]
dsn=pbx
synopsis=Action for direct GoSub(): select "Action" from "CallLevelE"("DNID" text, "cid" text default NULL, "Aliased" text default '', "bind" text default '')
escapecommas=off
readsql=select "Action" from "CallLevelE"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}','${SQL_ESC(${ARG4})}') LIMIT 1

[GET_ACTION_I]
dsn=pbx
synopsis=Action for direct GoSub(): select "Action" from "CallLevelI"("DNID" text, "cid" text default NULL)
escapecommas=off
readsql=select "Action" from "CallLevelI"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}') LIMIT 1

; Implements routing by routing-list, based on a set of prefix-lists
[GET_ROUTE]
dsn=pbx
synopsis=Non-escaped routing information: select "GetRoute"("List" bigint, "CID" text)
escapecommas=off
readsql=select "GetRoute"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}') LIMIT 1

[LAST_ANSWERED]
; Set(RES=${ODBC_LAST_ANSWERED(28585)});
dsn=cdr
synopsis=Retrieve time in seconds since last answered call was completed
readsql=SELECT extract('epoch' from(now() - (calldate + (duration || ' second')::interval)))::bigint from cdr where (dst = '${SQL_ESC(${ARG1})}') and (("x-domain" = '${SQL_ESC(${ARG2})}') or ("x-domain" is NULL)) and (disposition = 'ANSWERED') order by calldate DESC LIMIT 1

;[SURVEY]
; Set(ODBC_SURVEY(${NRec},${Exten},${UniqueId})=${Mark});
;dsn=cdr
;synopsis=Write mark to SurveyList: insert into "Survey" ("SurveyList","Exten","UniqueId","Mark")
;writesql=insert into "Survey" ("SurveyList","Exten","UniqueId","Mark") values ('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}','${SQL_ESC(${VAL1})}')

[AUTO_DIAL]
; Set(HASH(AutoDial)=${ODBC_AUTO_DIAL(${cid})});
; Set(ODBC_AUTO_DIAL(${cid})=${dnid});
dsn=pbx
readsql=select "Dst" from "AutoDial" where ("Src" = '${SQL_ESC(${ARG1})}') and ("PlacedAt" > (timestamp 'now' - interval '15 minutes')) LIMIT 1
writesql=insert into "AutoDial" ("Src","Dst") values ('${SQL_ESC(${ARG1})}','${SQL_ESC(${VAL1})}')

[AUTO_DIAL_RESULT]
; Set(ODBC_AUTO_DIAL_RESULT(${cid})=Busy);
; Set(ODBC_AUTO_DIAL_RESULT(${cid})=NoAnswer);
dsn=pbx
writesql=update "AutoDial" set "${SQL_ESC(${VAL1})}" = ("${SQL_ESC(${VAL1})}" + 1) where "Src" = '${SQL_ESC(${ARG1})}'

[MENU]
; Set(HASH(Menu)=${ODBC_MENU(${nrec})});
dsn=pbx
readsql=select * from "Menu" where "NRec" = '${SQL_ESC(${ARG1})}' LIMIT 1

[CAL]
dsn=pbx
readsql=select "InCalendar"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}') LIMIT 1

[INFORMER_LST]
; Set(HASH(Lst)=${ODBC_INFORMER_LST(${nrec})});
dsn=pbx
readsql=select * from "InformerMessages" where "NRec" = '${SQL_ESC(${ARG1})}' LIMIT 1

[INFORMER_MSG]
; Set(HASH(Msg)=${ODBC_INFORMER_MSG(${nrec})});
dsn=pbx
readsql=select * from "Informer" where "NRec" = '${SQL_ESC(${ARG1})}' LIMIT 1

[INFORMER_INS]
; Set(ODBC_INFORMER_INS(${nrec})=${phone});
dsn=pbx
writesql=insert into "Informer" ("InformerMessages", "Exten") values ('${SQL_ESC(${ARG1})}', '${SQL_ESC(${VAL1})}')

[INFORMER_ARC]
; Set(ODBC_INFORMER_ARC(${nrec})=${phone});
dsn=pbx
writesql=update "Informer" set "Archieved" = 'now' where ("InformerMessages" = '${SQL_ESC(${ARG1})}') and ("Exten" = '${SQL_ESC(${VAL1})}')

[INFORMER_CHK]
; Set(HASH(Msg)=${ODBC_INFORMER_CHK(${nrec},${EXTEN});
dsn=pbx
readsql=select * from "Informer" where ("InformerMessages" = '${SQL_ESC(${ARG1})}') and ("Exten" = '${SQL_ESC(${ARG2})}') and ("Archieved" = 'epoch') LIMIT 1

[INFORMER_COUNT]
; Set(ODBC_INFORMER_COUNT()=${nrec});
dsn=pbx
writesql=update "Informer" set "LastCall" = 'now', "Count" = "Count" + 1 where "NRec" = '${SQL_ESC(${VAL1})}'

[INFORMER_STATUS]
; if (${status}) Set(ODBC_INFORMER_STATUS(${nrec},${done})=${status});
dsn=pbx
writesql=update "Informer" set "LastStatus" = '${SQL_ESC(${VAL1})}', "Done" = '${SQL_ESC(${ARG2})}' where "NRec" = '${SQL_ESC(${ARG1})}'

[INFORMER_MAIL]
dsn=pbx
readsql=select * from "Mailer" where "NRec" = '${SQL_ESC(${ARG1})}' LIMIT 1

;[FAX_LST]
; Set(HASH(Lst)=${ODBC_FAX_LST(${nrec})});
;dsn=pbx
;synopsis=select * from "MailFax" where "NRec" = ARG1
;readsql=select * from "MailFax" where "NRec" = '${SQL_ESC(${ARG1})}' LIMIT 1

;[FAX_MSG]
; Set(HASH(Msg)=${ODBC_FAX_MSG(${nrec})});
;dsn=pbx
;synopsis=select * from "Fax" where "NRec" = ARG1
;readsql=select * from "Fax" where "NRec" = '${SQL_ESC(${ARG1})}' LIMIT 1

;[FAX_STATUS]
; if (${status}) Set(ODBC_STATUS_STATUS(${nrec},${done})=${status});
;dsn=pbx
;synopsis=update "Fax" set "LastStatus", "Done"
;writesql=update "Fax" set "LastStatus" = '${SQL_ESC(${VAL1})}', "Done" = '${SQL_ESC(${ARG2})}' where "NRec" = '${SQL_ESC(${ARG1})}'

[CONST] ; Storage for some significant constants
dsn=pbx
readsql=SELECT "Value" FROM "CONST" WHERE "Name"='${SQL_ESC(${ARG1})}' LIMIT 1

[VAR] ; Storage for some significant constants
dsn=pbx
readsql=SELECT "Value" FROM "VAR" WHERE "Name"='${SQL_ESC(${ARG1})}' LIMIT 1
writesql=SELECT "SetVAR"('${SQL_ESC(${ARG1})}','${SQL_ESC(${VAL1})}')

[EXTEN] ; Extensions owned by local Asterisk
; Usage from AEL is something like the below
; Set(HASH(RES)=${ODBC_EXTEN(28525)});
; Set(ODBC_EXTEN(28525,Timeout)=20);
dsn=pbx
; Read retrieves all fields into HASH()
;readsql=SELECT * FROM "Exten" WHERE ("Exten"='${SQL_ESC(${ARG1})}') and (("BIND"='${SQL_ESC(${ARG2})}') or ("BIND" is NULL) or ('${SQL_ESC(${ARG2})}'='')) ORDER BY "BIND" DESC LIMIT 1
;readsql=SELECT "Exten".*, "ExtenStatus".* FROM "Exten" LEFT JOIN "ExtenStatus" ON "Exten"."Exten" = "ExtenStatus"."Exten" WHERE ("Exten"."Exten"='${SQL_ESC(${ARG1})}') and (("Exten"."BIND"='${SQL_ESC(${ARG2})}') or ("Exten"."BIND" is NULL) or ('${SQL_ESC(${ARG2})}'='')) LIMIT 1
readsql=SELECT "Exten"."Exten", "Exten"."BIND", "Exten"."Type", "Exten"."Enabled", "Exten"."Context", "Exten"."MailTo", "Exten"."MonitorTo", "Exten"."CallLevel", "Exten"."CallLimit", "Exten"."ServiceList", "Exten"."PrefixList5", "Exten"."PrefixList6", "Exten"."ZoneList", "Exten"."CallList", "Exten"."Delay", "Exten"."TransferCall", "Exten"."SpawnCalls", "Exten"."TransferOnBusy", "Exten"."TransferOnTimeout", "Exten"."TransferSchedule", "Exten"."FeatureTransfer", "Exten"."FeaturePark", "Exten"."IVRTransfer", "Exten"."IVRMail", "Exten"."Timeout", "Exten"."Alias", "Exten"."AutoDial", "Exten"."MOH", "Exten"."RouteTag", "Exten"."Description", "Exten"."RouteGroup", "Exten"."Goodok", "Exten"."PickUpGroup", "Exten"."AllowedToPickUp", "Exten"."Region", "Exten"."Guid", "Exten"."RhombusAllowed", "Exten"."ExternPrefix", "Exten"."AssignedQueues", "Exten"."ExclusQueue", "ExtenStatus"."DND", "ExtenStatus"."TransferCall" FROM "Exten" LEFT JOIN "ExtenStatus" ON "Exten"."Exten" = "ExtenStatus"."Exten" WHERE ("Exten"."Exten"='${SQL_ESC(${ARG1})}') and (("Exten"."BIND"='${SQL_ESC(${ARG2})}') or ("Exten"."BIND" is NULL) or ('${SQL_ESC(${ARG2})}'='')) LIMIT 1
;readsql=select * from "Exten" where (("Exten"."Exten" = '${SQL_ESC(${ARG1})}') or ("Exten"."Exten" = '!' || '${SQL_ESC(${ARG1})}') or ("Exten"."Exten" = 'n' || '${SQL_ESC(${ARG1})}') or (("Exten"."Exten" = '!') and ("BIND" = '${SQL_ESC(
; Write adjusts value from ARG2 to specified field
writesql=UPDATE "Exten" SET "${ARG3}"='${SQL_ESC(${VAL1})}' WHERE ("Exten"='${SQL_ESC(${ARG1})}') and ("BIND"='${SQL_ESC(${ARG2})}')

[EXTEN_STATUS] ; Extensions owned by local Asterisk
dsn=pbx
; Read retrieves all fields into HASH()
readsql=SELECT * FROM "ExtenStatus" WHERE ("Exten"='${SQL_ESC(${ARG1})}') LIMIT 1
; Write adjusts value from ARG2 to specified field
writesql=UPDATE "ExtenStatus" SET "${ARG3}"='${SQL_ESC(${VAL1})}' WHERE ("Exten"='${SQL_ESC(${ARG1})}')

[CALLBACK] ; Callback-dedicated peers. !!!MUST BE READ-ONLY for Asterisk!!!
; Usage from AEL is something like the below
; Set(HASH(RES)=${ODBC_CALLBACK(${EXTEN},${CALLERID(num)})});
dsn=pbx
; Read retrieves all fields into HASH()
readsql=SELECT * FROM "CallBack" WHERE ("Exten"='${SQL_ESC(${ARG1})}') and ("CID"='${SQL_ESC(${ARG2})}') LIMIT 1

[ALIAS] ; Egress aliases
; Usage from AEL is something like the below
; Set(HASH(RES)=${ODBC_ALIAS(${CALLERID(num)},1)});
; Set(ODBC_ALIAS(${CALLERID(num)},1)=33);
dsn=pbx
; Read retrieves all fields into HASH()
synopsis=read:SELECT * FROM "Aliases" WHERE "Egress" and ("Exten"=${cid}) and ("Cell"=${dnid}); write:SetAlias()
readsql=SELECT * FROM "Aliases" WHERE "Egress" and ("Exten"='${SQL_ESC(${ARG1})}') and ("Cell"='${SQL_ESC(${ARG2})}') and (("BIND"='${SQL_ESC(${ARG3})}') or ("BIND" is NULL) or ('${SQL_ESC(${ARG3})}'='')) ORDER BY "BIND" DESC LIMIT 1
; Only 1 SQL statement is allowed, so use proper function
writesql=SELECT "SetAlias"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}','${SQL_ESC(${VAL1})}')

[ALIAS_LABEL] ; Voice label for Aliases
; Use [ALIAS] to read HASH()
; Set(ODBC_ALIAS_LABEL(${CALLERID(num)},1)=${CALLERID(num)}1);
dsn=pbx
writesql=UPDATE "Aliases" SET "Label"='${SQL_ESC(${VAL1})}' WHERE ("Exten"='${SQL_ESC(${ARG1})}') and ("Cell"='${SQL_ESC(${ARG2})}')

[ALIAS_I] ; Ingress aliases
dsn=pbx
synopsis=SELECT "AliasI"(${dnid}), ${num})
readsql=SELECT "AliasI"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}');

[ZONE] ; Check whether number to Dial() conforms to local zone. !!!MUST BE READ-ONLY for Asterisk!!!
dsn=pbx
; Set(RES=${ODBC_ZONE(812,911,9583253)});
readsql=SELECT "InZone"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}')

[ZONE_IN_LIST] ; Check whether number to Dial() conforms to zone from given list.
dsn=pbx
; Set(RES=${ODBC_ZONE_IN_LIST(1,921,9583253)});
readsql=SELECT "InZoneList"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}')

[CALLLIST] ; Retrieve settings for some CallList
dsn=pbx
readsql=SELECT * FROM "CallList" WHERE "NRec"='${SQL_ESC(${ARG1})}' LIMIT 1

[CALLS] ; Retrieve Calls from CallList
dsn=pbx
;// Retrieve call list
; i=0;
; While (${i}>=0) {
;  Set(HASH(RES)=${ODBC_CALLS(1,i)});
;  If (HASH(RES)="") {
;   i=-1;
;  };
; };
readsql=SELECT * from "Calls" WHERE "CallList"='${SQL_ESC(${ARG1})}' ORDER BY "Order" LIMIT 1 OFFSET '${SQL_ESC(${ARG2})}'

[CALL_IN_LIST]
dsn=pbx
; Check whether number exists in CallList
readsql=SELECT 1 as "EXISTS" from "Calls" WHERE ("CallList"='${SQL_ESC(${ARG1})}') and ("Exten" = '${SQL_ESC(${ARG2})}') LIMIT 1

[PREFIXLIST] ; Retrieve settings for some PrefixList, if it will be needed elthewhere...
dsn=pbx
readsql=SELECT * FROM "CallList" WHERE "NRec"='${SQL_ESC(${ARG1})}' LIMIT 1

[PREFIX] ; Check if number contains prefix from list
dsn=pbx
; Set(RES=${ODBC_PREFIX(1,8123202020)});
readsql=SELECT "CheckPrefix"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}')

[FUNC] ; Retrieve function for Exten if present in list
dsn=pbx
; Set(HASH(RES)=${ODBC_FUNC(${EXTEN},${CALLERID(num)})});
readsql=SELECT * FROM "Func" WHERE ("Exten"='${SQL_ESC(${ARG1})}') and (("CID"='${SQL_ESC(${ARG2})}') or ("CID"='ALL')) and (("BIND"='${SQL_ESC(${ARG3})}') or ("BIND" is NULL) or ('${SQL_ESC(${ARG3})}'='')) ORDER BY "BIND" DESC, "CID" LIMIT 1

[ROUTE] ; Get route for external call
dsn=pbx
; Retrieve first available route in such way (dont't forget to check ${RES} for empty value)
; Set(RES=${ODBC_ROUTE(${CALLERID(num)},${CALLERID(dnid)},0)});
readsql=SELECT "Channels"."Channel" FROM "Route","Channels" WHERE ("Channels"."NRec"="Route"."Channel") and ("Level" in ('${SQL_ESC(${ARG3})}',0)) and ('${SQL_ESC(${ARG1})}'>="SourceLow") and ('${SQL_ESC(${ARG1})}'<="SourceHigh") and ('${SQL_ESC(${ARG2})}'>="DestinationLow") and ('${SQL_ESC(${ARG2})}'<="DestinationHigh") ORDER BY "Level" DESC, "Order" LIMIT 1 OFFSET '${SQL_ESC(${ARG4})}'

[PEER] ; Get peer for inter-PBX call
dsn=pbx
; Retrieve first available route in such way (dont't forget to check ${RES} for empty value)
; Set(RES=${ODBC_ROUTE(${CALLERID(num)},${CALLERID(dnid)},0)});
readsql=SELECT * FROM "Friends" WHERE ('${SQL_ESC(${ARG1})}'>="FromExten") and ('${SQL_ESC(${ARG1})}'<="ToExten") and (("BIND"='${SQL_ESC(${ARG2})}') or ("BIND" is NULL) or ('${SQL_ESC(${ARG2})}'='')) ORDER BY "BIND" NULLS LAST LIMIT 1

[CID] ; Get caller id for external call
; Set(id=${ODBC_CID(${cid});
dsn=pbx
readsql=SELECT "CID" FROM "CID" WHERE ('${SQL_ESC(${ARG1})}'>="FromExten") and ('${SQL_ESC(${ARG1})}'<="ToExten") and (("BIND"='${SQL_ESC(${ARG2})}') or ("BIND" is NULL) or ('${SQL_ESC(${ARG2})}'='')) LIMIT 1

[ABC]
dsn=pbx
synopsis=SELECT * from "QueryABC"(ARG1) LIMIT 1
readsql=SELECT * from "QueryABC"('${SQL_ESC(${ARG1})}') LIMIT 1

[URL]
dsn=pbx
synopsis=SELECT "URL" FROM "Event"
readsql=SELECT "URL" FROM "Event" WHERE ("Line"='${SQL_ESC(${ARG1})}') and (("BIND"='${SQL_ESC(${ARG2})}') or ("BIND" is NULL) or ('${SQL_ESC(${ARG2})}'='')) ORDER BY "BIND" DESC LIMIT 1

[MANGLE]
dsn=pbx
synopsis=function "Mangle"("mangle" bigint, "dnid" text, "cid" text default NULL)
readsql=SELECT * FROM "Mangle"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}','${SQL_ESC(${ARG3})}') LIMIT 1

[SPAM]
dsn=pbx
synopsis=SPAM engine loopback
readsql=SELECT * FROM "Spam" WHERE "NRec" = '${SQL_ESC(${ARG1})}' LIMIT 1
writesql=UPDATE "Spam" SET "Done" = '${SQL_ESC(${VAL1})}', "Attempt" = "Attempt" + 1, "Cause" = '${SQL_ESC(${ARG2})}' WHERE "NRec" = '${SQL_ESC(${ARG1})}'

[PICKUP]
dsn=pbx
synopsis=select extentions to pickup
readsql=select * from "pickupgroup"('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}')

[GUID]
dsn=pbx
synopsis=select guid from extention by (bind, exten)
readsql=select get_guid('${SQL_ESC(${ARG1})}','${SQL_ESC(${ARG2})}')

[SIP_PEER]
dsn=pbx
synopsis=select * FROM sip where name='${SQL_ESC(${ARG1})}'
readsql=select * FROM sip where name='${SQL_ESC(${ARG1})}'
