// Dynamic menu for Asterisk
macro menu(nrec) {
// Do menu processing based on "Menu" table
 catch h { // whitout a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }

 ClearHash(menu);
 Set(HASH(menu)=${ODBC_MENU(${nrec})});

 if ("${HASH(menu,NRec)}"="") { // No such menu!
  return;
 }

 Set(CHANNEL(language)=ru);
 Answer(1000);
 num=;
 loop=0;
 while (("${num}"="")&(${loop}<=${HASH(menu,Repeat)})&("${hang}"!="1")) {
  if ((${loop}=0)&("${HASH(menu,Hello)}"!="")) {
   Read(num,menu/${HASH(menu,Hello)},1,,,1);
  } else {
   Read(num,menu/${HASH(menu,Prompt)},1,,,${HASH(menu,Timeout)});
  }
  loop=${loop}+1;

  if ("${READSTATUS}"="TIMEOUT") {
   if ("${HASH(menu,TimeoutAction)}"!="") { // Do something for stupid user (on no key pressed)
    Set(func=${HASH(menu,TimeoutAction)});
    if ("${func}"!="BACK") { // Call this function
     Set(fn=${CUT(func,:,1)});
     Set(arg=${CUT(func,:,2)});
     &${fn}(${arg});
     Set(HASH(menu)=${ODBC_MENU(${nrec})}); // Because it is rewritten on recursion!!!
    } else { // Try return to previous menu
     if ("${HASH(menu,Parent)}"!="") {
      NoOp(Parent=${HASH(menu,Parent)});
     }
    }
   } // if ("${HASH(menu,TimeoutAction)}"!="")
  }

  if ("${num}"!="") { // Some key pressed, excepting "#"
   Set(func=${HASH(menu,${num})});
//   NoOp(func=${func});
   num=;
   if ("${func}"!="") {
    if ("${func}"!="BACK") { // Call this function
     Set(fn=${CUT(func,:,1)});
     Set(arg=${CUT(func,:,2)});
     &${fn}(${arg});
     Set(HASH(menu)=${ODBC_MENU(${nrec})}); // Because it is rewritten on recursion!!!
    } else { // Try return to previous menu
     if ("${HASH(menu,Parent)}"!="") {
      NoOp(Parent=${HASH(menu,Parent)});
      return;
     }
    }
   } // if (${func})
  }
 } // while

// NoOp(END MENU);
 return;
} // macro menu(nrec)

//macro play(file) { // see func.ael
// catch h { // whitout a catch, dialplan stops execution on hangup !!!
//  return;
// }
// Playback(${file});
// return;
//}

macro read(digits,prefix,h) {
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
 num=;
 Read(num,menu/beep,${digits},,,1);
 if ("${num}"!="") {
  &dial(${prefix}${num},${h},);
 }
 if ("${h}"="1") {
  hang=1;
  Hangup;
 }
 return;
} // macro read(digits,h)

macro dial(r,h,timeout) {
// Dial ${ext} on LOCAL@iax channel, then hangup if h=1
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }

 if ("${timeout}"="") {
  timeout=300;
 }

 Dial(LOCAL/${r}@iax/n,${timeout},TtKkfg);
 NoOp(DIALSTATUS=${DIALSTATUS});
 if ("${DIALSTATUS}"!="ANSWER") {
  Playback(all-circuits-busy-now);
 }

 if ("${h}"="1") {
  hang=1;
  Hangup;
 }
 return;
} // macro dial(r)

macro clock(nrec,f1,f2) {
// Clock-based switch: take calendar(nrec), exec &f1(${arg1}) true, otherwise &f2(${arg2})
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
 if ("${ODBC_CAL(${nrec},${CALLERID(num)})}"="1") {
  Set(fn=${CUT(f1,:,1)});
  Set(arg=${CUT(f1,:,2)});
 } else {
  Set(fn=${CUT(f2,:,1)});
  Set(arg=${CUT(f2,:,2)});
 }
 &${fn}(${arg});
 return;
} // macro clock(nrec)

macro balance_fallback(route,fallback) {
// Pass a call to the route with min load
// Use random route in case of equal load
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
 Set(r1=${CUT(route,:,1)});
 Set(r2=${CUT(route,:,2)});
 Set(r3=${CUT(route,:,3)});
 Set(r4=${CUT(route,:,4)});


 route=${r1};
 c1=${GROUP_COUNT(${r1}@0)}+${GROUP_COUNT(${r1}@1)};
 if (DEVICE_STATE(Custom:${r1})=INUSE) c1=${c1}+1;

 if (${r2}) {
  c2=${GROUP_COUNT(${r2}@0)}+${GROUP_COUNT(${r2}@1)};
  if (DEVICE_STATE(Custom:${r2})=INUSE) c2=${c2}+1;
  if (${c2}<${c1}) {
   c1=${c2};
   route=${r2};
  }
  if (${c2}=${c1}) {
   if (${RAND(1,256)}>128) route=${r2};
  }
 }
 if (${r3}) {
  c3=${GROUP_COUNT(${r3}@0)}+${GROUP_COUNT(${r3}@1)};
  if (DEVICE_STATE(Custom:${r3})=INUSE) c3=${c3}+1;
  if (${c3}<${c1}) {
   c1=${c3};
   route=${r3};
  }
  if (${c3}=${c1}) {
   if (${RAND(1,256)}>128) route=${r3};
  }
 }
 if (${r4}) {
  c4=${GROUP_COUNT(${r4}@0)}+${GROUP_COUNT(${r4}@1)};
  if (DEVICE_STATE(Custom:${r4})=INUSE) c4=${c4}+1;
  if (${c4}<${c1}) {
   c1=${c4};
   route=${r4};
  }
  if (${c4}=${c1}) {
   if (${RAND(1,256)}>128) route=${r4};
  }
 }
 Set(__NO_TRANSFER=1);
 Dial(LOCAL/${route}@iax/n,300,TtKkfg);

 if ("${DIALSTATUS}"!="ANSWER") {
  Dial(LOCAL/${fallback}@iax/n,300,TtKkfg);
 }
 return;
} // macro balance(r1,r2,r3,r4)

macro switch_transfer(trnf) {
// Switches "TransferCall" on calling extension On(trnf)|Off
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }

 if ("${HASH(ext,TransferCall)}"="") {
  Set(ODBC_EXTEN(${HASH(ext,Exten)},${HASH(ext,BIND)},TransferCall)=${trnf});
  Playback(ivr/transfer-on);
 } else {
  Set(ODBC_EXTEN(${HASH(ext,Exten)},${HASH(ext,BIND)},TransferCall)=);
  Playback(ivr/transfer-off);
 }
 return;
} // macro switch_transfer(trnf)

macro switch_dnd() {
// Switches "DND" mode on calling extension On|Off
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }

 if ("${HASH(ext,DND)}"!="1") {
  Set(ODBC_EXTEN(${HASH(ext,Exten)},${HASH(ext,BIND)},DND)=1);
  ClearHash(ext);
  Set(HASH(ext)=${ODBC_EXTEN(${cid})},${BIND});
  DEVICE_STATE(Custom:${cid})=BUSY;
  Playback(ivr/transfer-on);
 } else {
  Set(ODBC_EXTEN(${HASH(ext,Exten)},${HASH(ext,BIND)},DND)=0);
  ClearHash(ext);
  Set(HASH(ext)=${ODBC_EXTEN(${cid})},${BIND});
  Playback(ivr/transfer-off);
 }
 return;
} // macro switch_dnd()
