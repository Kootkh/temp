//This is the improved version of Switch macro, adapted for twelve argiments in function engine
// Just call function "fn". Variables may be set as comma-separated list
// insert into "Func" values ('090','ALL',NULL,'Switch','Exten(555,VOIX)','DialSuffix=/123');
// if Var (P2 = mywar = 'value') is not null - set variable on channel
//if Limit is not null - switch is passing thru Limit calls simultaneously and is routing excess to FallBack
//ONLY if SmartSwitch is the enty point of iax-in number, MailToNoAnswer is specifying the email-address, to wich the messages of non-answered calls are sent
//Note that both kinds of non-answered calls are generating same message - caller-ended and timeout-ended.
macro SmartSwitch(fn,Var,Limit,FallBack,MailToNoAnswer) {
 NoOp(${leg1}>>${leg2} FUNCTION Switch(${fn},${Var},${Limit},${FallBack},${MailToNoAnswer}));
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }

 Set(DATA=${DATA},FUNC=${CONTEXT};LIMIT=${Limit});
 Set(CDR(x-data)={${DATA:1}});

 if ("${Limit}"!="") {
  Set(LOCAL(RouteGroup)=${CUT(Limit,:,2)});
  if ("${RouteGroup}"="") Set(LOCAL(RouteGroup)=${dnid});

 Set(LOCAL(Limit)=${CUT(Limit,:,1)});

  Set(GROUP(R)=${RouteGroup});
  if (${GROUP_COUNT(${RouteGroup}@R)}>${Limit}) {
   if ("${FallBack}"="") {
    Congestion();
    return;
   } else Set(LOCAL(fn)=${FallBack});
  }
 }

 Set(RESULT=Invalid Func);
 if ("${fn}"="") return;

 RESULT=OK;

 for (LOCAL(i)=1; ${i}<=${FIELDQTY(Var,\,)}; LOCAL(i)=${i}+1) {
  Set(LOCAL(v)=${CUT(Var,\,,${i})});
  Set(LOCAL(val)=${CUT(v,=,2)});
  Set(${CUT(v,=,1)}=${EVAL(${val})});
 }

 #include "ael/func/FUNC.INC"

// if ("${hang}"="1") Hangup();
 return;
} // SmartSwitch(fn,Var,Limit,FallBack,MailToNoAnswer)
