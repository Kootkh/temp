// Add|unpause queue agent
// insert into "Func" values ('090','ALL',NULL,'AgentOn','3370303','444','3370303*444','Func(090.1)');
// Q*459*3370303
macro AgentOn(Queue,Line,Device,fn) {
 NoOp(${leg1}>>${leg2} FUNCTION AgentOn(${Queue},${Line},${Device},${fn}));
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
 if ("${from}"="transfer") { // Pass transfers to queue
  &queue(${Queue},,,);
  return;
 }

 Answer;
 if ("${Line}"="") Set(LOCAL(Line)=${cid});
 if ("${Device}"="") Set(LOCAL(Device)=${dnid});
 DEVICE_STATE(Custom:${Device})=INUSE;

 Set(ODBC_EXTEN_STATUS(${Line},DND)=0);
 ClearHash(ext);
 Set(HASH(ext)=${ODBC_EXTEN(${Line})},${BIND});
 if ("${BIND}"!="") Set(LOCAL(Line)=!${BIND}+${Line});

//  AddQueueMember(${Queue},LOCAL/${Line}@iax/n,3,,${Queue}*${Line},hint:Q*${Line}*${Queue}@blf); // Make distinct slots for upper queues
  AddQueueMember(${Queue},LOCAL/${Line}@iax/n,,,${Queue}*${Line});
 Set(RESULT=${AQMSTATUS});
 if ("${RESULT}"!="NOSUCHQUEUE") {
  UnpauseQueueMember(${Queue},LOCAL/${Line}@iax/n,,AgentOn);
  Set(RESULT=${UPQMSTATUS});
  if ("${RESULT}"="UNPAUSED") RESULT=OK;
 } else RESULT=ERR;


 NoOp(RESULT=${RESULT});

 if ("${fn}"="") return;
 #include "ael/func/FUNC.INC"
 return;
} // macro AgentOn(Queue,Line,Device,fn)




macro AgentIn(Queue,Interface,ACL,fn) {
 NoOp(${leg1}>>${leg2} FUNCTION AgentIn(${Queue},${Interface},${ACL},${fn}));
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
 if ("${from}"="transfer") { // Pass transfers to queue
  &queue(${Queue},,,);
  return;
 }

 Answer;
 if ("${Line}"="") Set(LOCAL(Line)=${cid});
 if ("${Device}"="") Set(LOCAL(Device)=${dnid});
 DEVICE_STATE(Custom:${Device})=INUSE;
 NoOp(maxx: agentin: Queue ${Queue},Interface ${Interface},ACL ${ACL},fn ${fn},DEVICE ${Device} line ${Line});

if ("${Interface}"!="") {
Set(LOCAL(Line)=${cid});
 Set(LOCAL(Line)=${CUT(Interface,/,2)});
 Set(LOCAL(Line)=${CUT(Line,@,1)});
 Set(LOCAL(Line)=${CUT(Line,+,2)});
 Set(LOCAL(Line)=${FILTER(0-9,${Line})});
 NoOp(maxx: Line ${Line});
} else {
Set(Interface=LOCAL/${BIND}+${cid}@iax/n);
Set(LOCAL(Line)=${FILTER(0-9,${Line})});
}
NoOp(maxx: Inteface  ${Interface});

 Set(ODBC_EXTEN_STATUS(${Line},DND)=0);
 ClearHash(ext);
 Set(HASH(ext)=${ODBC_EXTEN(${cid})},${BIND});
// if ("${BIND}"!="") Set(LOCAL(Line)=!${BIND}+${Line});
//  if ("${BIND}"!="") Set(LOCAL(Line)=${BIND}+${Line});

if ("${ACL}"!="") {
 Set(LOCAL(ALLOW)=${ODBC_ACLCHECK(${ACL},${Line})});
 NoOp(permit for acl ${ACL} and line ${Line} is ${ALLOW});
 } else {
 Set(LOCAL(ALLOW)=0);
 }

// Set(LOCAL(ALLOW)=${ODBC_ACLCHECK(${ACL},${Line})});
// NoOp(permit for acl ${ACL} and line ${Line} is ${ALLOW});
 if("${ALLOW}"!="1") {
 NoOp(the operator ${Line} is NOT presented in ACL, so he/she is allowed to participate in queue ${Queue});
 AddQueueMember(${Queue},${Interface},,,);
 Set(RESULT=${AQMSTATUS});
 if ("${RESULT}"!="NOSUCHQUEUE") {
  UnpauseQueueMember(${Queue},${Interface},,AgentOn);
  Set(RESULT=${UPQMSTATUS});
  }
  if ("${RESULT}"="UNPAUSED") { 
   Set(RESULT=OK);
   } else {
   Set(RESULT=ERR);
   }
 } else {
 NoOp(the operator ${Line} is presented in ACL, so he/she is denied to participate in queue ${Queue});
 Set(RESULT=ERR);
 }

if ("${RESULT}"="OK") {
 NoOp(RESULT=${RESULT});
 Playback(agent-loginok);
 }

 if ("${fn}"="") return;
 #include "ael/func/FUNC.INC"
 return;
} // macro AgentIn(Queue,Line,Device,fn)






// Remove|pause queue agent
// insert into "Func" values ('090','ALL',NULL,'AgentOff','3370303','444','3370303*444','Func(090.1)');
macro AgentOff(Queue,Line,Device,fn) {
 NoOp(${leg1}>>${leg2} FUNCTION AgentOff(${Queue},${Line},${Device},${fn}));
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
 if ("${Line}"="") Set(LOCAL(Line)=${cid});
 if ("${Device}"="") Set(LOCAL(Device)=${Queue}*${cid});
 DEVICE_STATE(Custom:${Device})=NOT_INUSE;

 if ("${BIND}"!="") Set(LOCAL(Line)=!${BIND}+${Line});
 RemoveQueueMember(${Queue},LOCAL/${Line}@iax/n);
 Set(RESULT=${RQMSTATUS});
 if ("${RESULT}"!="REMOVED") {
  PauseQueueMember(${Queue},LOCAL/${Line}@iax/n,,AgentOff);
  Set(RESULT=${PQMSTATUS});
  if ("${RESULT}"="PAUSED") RESULT=OK;
 } else RESULT=OK;
if ("${RESULT}"="OK") {
 NoOp(maxx: result is {RESULT});
 Playback(agent-loggedoff);
 }

 NoOp(RESULT=${RESULT});

 if ("${fn}"="") return;
 #include "ael/func/FUNC.INC"
 return;
} // macro AgentOff(Queue,Line,Device,fn)






macro AgentOut(Queue,Interface,ACL,fn) {
 NoOp(${leg1}>>${leg2} FUNCTION AgentOut(${Queue},${Interface},${ACL},${fn}));
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
 if ("${from}"="transfer") { // Pass transfers to queue
  &queue(${Queue},,,);
  return;
 }

 Answer;
 if ("${Line}"="") Set(LOCAL(Line)=${cid});
 if ("${Device}"="") Set(LOCAL(Device)=${dnid});
 DEVICE_STATE(Custom:${Device})=NOT_INUSE;
 NoOp(maxx: agentout: Queue ${Queue},Interface ${Interface},ACL ${ACL},fn ${fn},DEVICE ${Device} line ${Line});

if ("${Interface}"!="") {
Set(LOCAL(Line)=${cid});
 Set(LOCAL(Line)=${CUT(Interface,/,2)});
 Set(LOCAL(Line)=${CUT(Line,@,1)});
 Set(LOCAL(Line)=${CUT(Line,+,2)});
 Set(LOCAL(Line)=${FILTER(0-9,${Line})});
 NoOp(maxx: Line ${Line});
} else {
Set(Interface=LOCAL/${BIND}+${cid}@iax/n);
Set(LOCAL(Line)=${FILTER(0-9,${Line})});
}
NoOp(maxx: Inteface  ${Interface});

 Set(ODBC_EXTEN_STATUS(${Line},DND)=0);
 ClearHash(ext);
 Set(HASH(ext)=${ODBC_EXTEN(${cid})},${BIND});


if ("${ACL}"!="") {
Set(LOCAL(ALLOW)=${ODBC_ACLCHECK(${ACL},${Line})});
 NoOp(permit for acl ${ACL} and line ${Line} is ${ALLOW});
} else {
Set(LOCAL(ALLOW)=0);
}
 if("${ALLOW}"!="1") {
 NoOp(the operator ${Line} is NOT presented in ACL, so he/she is allowed to out from queue ${Queue});
 RemoveQueueMember(${Queue},${Interface});
 Set(RESULT=${RQMSTATUS});
 if ("${RESULT}"!="REMOVED") {
  PauseQueueMember(${Queue},${Interface},,AgentOff);
  Set(RESULT=${PQMSTATUS});
  if ("${RESULT}"="PAUSED") {
   Set(RESULT=OK);
   } else {
   Set(RESULT=ERR);
   }
  } else {
  Set(RESULT=OK);
  }
 } else {
 NoOp(the operator ${Line} is presented in ACL, so he/she is denied to out from queue ${Queue});
 Set(RESULT=ERR);
 }

if ("${RESULT}"="OK") {
 NoOp(RESULT=${RESULT});
 Playback(agent-loggedoff);
}

 if ("${fn}"="") return;
 #include "ael/func/FUNC.INC"
 return;
} // macro AgentOut(Queue,Line,Device,fn)








macro AgentSwitch(Queue,Line,Device,fn) {
 NoOp(${leg1}>>${leg2} FUNCTION AgentSwitch(${Queue},${Line},${Device},${fn}));
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
 if ("${from}"="transfer") { // Pass transfers to queue
  &queue(${Queue},,,);
  return;
 }

 Answer;
 if ("${Line}"="") Set(LOCAL(Line)=${cid});
 if ("${Device}"="") Set(LOCAL(Device)=${dnid});
 if ("${DEVICE_STATE(Custom:${Device})}"="INUSE") {
  &AgentOff(${Queue},${Line},${Device},${fn});
 } else {
  &AgentOn(${Queue},${Line},${Device},${fn});
 }

 return;
}

// Call function "f1" if there are more then "Threshold" agents in queue, "f2" otherwise
// insert into "Func" values ('090','ALL',NULL,'QueueActive','3300058','_Dial(LOCAL/28584@iax/n|10|TtKkfgm)','_Dial(LOCAL/28585@iax/n|10|TtKkfgm)','0');
macro QueueActive(QueueName,f1,f2,Threshold) {
 NoOp(${leg1}>>${leg2} FUNCTION QueueActive(${QueueName},${f1},${f2},${Threshold}));
 catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }

 Set(RESULT=Invalid QueueName);
 if ("${QueueName}"="") return;
 Set(RESULT=Invalid Func);
 if ("${f1}"="") return;
 if ("${f2}"="") Set(f2=${f1});

 if ("${Threshold}"="") Set(Threshold=0);

 RESULT=OK;

 Set(LOCAL(fn)=${f2});
 if (${QUEUE_MEMBER(${name},logged)}>${Threshold}) Set(LOCAL(fn)=${f1});

 #include "ael/func/FUNC.INC"
 return;
} // macro QueueActive(QueueName,f1,f2,Threshold)


macro PauseQueue(){
 NoOp(${leg1}>>${leg2} mcro PauseQueue);
 Log(DEBUG,Bind - ${BIND}  Line - ${Line}, Leg1 - ${leg1});   //Diim
 PauseQueueMember(,LOCAL/!${BIND}+${leg1}@iax/n,,Pause);
 Playback(agent-loggedoff);
 return;
} //macro PauseQueue


macro UnPauseQueue(){
 NoOp(${leg1}>>${leg2} mcro PauseQueue);
 Log(DEBUG,Bind - ${BIND} Line - ${Line}, Leg1 - ${leg1});   //Diim
 UnpauseQueueMember(,LOCAL/!${BIND}+${leg1}@iax/n,,UnPause);
 Playback(agent-loginok);
 return;
} //macro UnPauseQueue

//вход во все разрешенные очереди.
macro MassPauseQueue() {
 NoOp(${leg1}>>${leg2} FUNCTION massPauseQueue);
catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
    Log(DEBUG,Bind - ${BIND} Line - ${Line}, Leg1 - ${leg1});   //Diim
    ClearHash(ext);
     Set(HASH(ext)=${ODBC_EXTEN(${leg1},${BIND})});
    Log(DEBUG,"${HASH(ext,AssignedQueues)}");
    Set(LOCAL(AssignedQueue)=${HASH(ext,AssignedQueues)});

    while ("${AssignedQueue}" != ""){
	Set(LOCAL(queue)=${SHIFT(AssignedQueue)});
        Log(DEBUG,Diim qeue  - ${queue});
	PauseQueueMember(${queue},LOCAL/${BIND}+${cid}@iax/n);

    }// end while
    Playback(agent-loggedoff);
    return;
}//macro MassPauseQueue


//снять с паузы все разрешенные очереди
macro MassUnPauseQueue() {
 NoOp(${leg1}>>${leg2} FUNCTION massPauseQueue);
catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
    Log(DEBUG,Bind - ${BIND} Line - ${Line}, Leg1 - ${leg1});   //Diim
    ClearHash(ext);
     Set(HASH(ext)=${ODBC_EXTEN(${leg1},${BIND})});
    Log(DEBUG,"${HASH(ext,AssignedQueues)}");
    Set(LOCAL(AssignedQueue)=${HASH(ext,AssignedQueues)});

    while ("${AssignedQueue}" != ""){
    Set(LOCAL(queue)=${SHIFT(AssignedQueue)});
        Log(DEBUG,Diim qeue  - ${queue});
    UnpauseQueueMember(${queue},LOCAL/${BIND}+${cid}@iax/n);

    }// end while
    Playback(agent-loginok);
    return;
}//macro massUnPauseQueue


macro MassRemoveQueue() {
 NoOp(${leg1}>>${leg2} FUNCTION MassRemoveQueue);
catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
    Log(DEBUG,Bind - ${BIND} Line - ${Line}, Leg1 - ${leg1});   //Diim
    ClearHash(ext);
     Set(HASH(ext)=${ODBC_EXTEN(${leg1},${BIND})});
    Log(DEBUG,"${HASH(ext,AssignedQueues)}");
    Set(LOCAL(AssignedQueue)=${HASH(ext,AssignedQueues)});

    while ("${AssignedQueue}" != ""){
    Set(LOCAL(queue)=${SHIFT(AssignedQueue)});
        Log(DEBUG,Diim qeue  - ${queue});
    //RemoveQueueMember(${queue},LOCAL/${BIND}+${leg1}@iax/n);
    RemoveQueueMember(${queue},LOCAL/${BIND}+${cid}@iax/n);

    }// end while
    Playback(agent-loggedoff);
    return;
}//macro MassRemoveQueue


//вход во все разрешенные очереди
macro MassAddQueue() {
 NoOp(${leg1}>>${leg2} FUNCTION MassAddQueue);
catch h { // without a catch, dialplan stops execution on hangup !!!
  hang=1;
  return;
 }
    Log(DEBUG,Bind - ${BIND} Line - ${Line}, Leg1 - ${leg1});   //Diim
    ClearHash(ext);
     Set(HASH(ext)=${ODBC_EXTEN(${leg1},${BIND})});
    Log(DEBUG,"${HASH(ext,AssignedQueues)}");
    Set(LOCAL(AssignedQueue)=${HASH(ext,AssignedQueues)});


    while ("${AssignedQueue}" != ""){
    Set(LOCAL(queue)=${SHIFT(AssignedQueue)});
        Log(DEBUG,Diim qeue  - ${queue}  EXCL  ${HASH(ext,ExclusQueue)} );

	//ExclusQueue дропаем всех кто в очереди если чел эксклюзив
	if("${HASH(ext,ExclusQueue)}"="1"){
		Set(mlist=${QUEUE_MEMBER_LIST(${queue})});
		Log(DEBUG, Line - ${Line}, Leg1 - ${leg1} mlist - ${mlist} Que - ${queue} );   //Diim
		while ("${mlist}" != ""){
		Set(LOCAL(dmember)=${SHIFT(mlist)});
		Log(DEBUG, RemoveQueueMember(${queue},${dmember}));
		RemoveQueueMember(${queue},${dmember});
	}
    }
    //DumpChan();
//	AddQueueMember(${queue},LOCAL/${BIND}+${leg1}@iax/n);
	AddQueueMember(${queue},LOCAL/${BIND}+${cid}@iax/n,3,,${queue}*${extd},Custom:${extd}); // теперь здесь просто, кастом хинт для блф и иже

    }// end while
    Playback(agent-loginok);
    return;
}//macro MassAddQueue


