// !!! OLD routing schema: local extensions
macro exten(res) { // Call to internal extension, hashed in res
// Consider any transfer is outgoing call with CallLevel taked from ${res}
 h=h;
 NoOp(CHANNELS exten = ${CHANNEL} :: ${uniqueid}>${leg1}>${leg2}>${dnid});
 NoOp(maxx: exten: begin exten macro);
 //DumpChan();

 Set(HASH(res)=${ODBC_EXTEN(${dnid},${BIND})});
 if("${HASH(res,Exten)}"="") return;
 if("${HASH(res,Exten)}"="!") Set(HASH(res,Exten)=!${leg2});  // TRUNK extension

 if ("${BIND}"="") Set(__BIND=${HASH(res,BIND)});

 __n2=${HASH(res,Exten)};
 Set(CHANNEL(accountcode)=${leg2});

if (${LEN(${CDR(last_guid)})}=0) {
    Set(CDR(last_guid)=${HASH(res,Guid)});
    CELGenUserEvent(last_guid,${CDR(last_guid)});
}

 Set(CDR(x-domain)=${BIND});
 Set(CHANNEL(userfield)=${BIND});

 Set(__ExtenRegion=${HASH(res,Region)});

 NoOp(${leg1}>>${leg2} FUNCTION exten(${HASH(res,Exten)},${BIND}));
 goto ${HASH(res,Exten)}|1; // CDR hack

 catch h {
  hang=1;
  if ("${ringing}"="1"&${GROUP_COUNT(${ext}@O)}=0) Set(ODBC_LINE_STATUS(${ext},${BIND})=${DIALSTATUS});

  if ("${DIALSTATUS}"="ANSWER"&${HASH(res,Delay)}>0&"${GROUP(B)}"=""&"${NO_SLEEP}"="") {
   if ("${GROUP(O)}"!="") {
    Set(GROUP(O)=); // Outgoing must be cleaned now, if one exists
//    &InUse(${cid});
    &InUse(${HASH(ext,Exten)});
   }
   Set(GROUP(B)=${ext});  // Delayed channel must stay BUSY during sleep
   Playtones(Busy);
   System(/bin/sleep ${HASH(res,Delay)}s); // Remember that simple Wait() will not work here!!!;
  }
  Set(GROUP(B)=);

  Set(HASH(res)=${ODBC_EXTEN(${dnid},${BIND})}); // May been altered along the call!!!
  if ("${HASH(res,DND)}"!="1"&"${ringing}"="1") &InUse(${ext});

  NoOp(CHANNELS exten hang = ${CHANNEL} :: ${uniqueid}>${leg1}>${leg2}>${dnid});
  NoOp(PARKEDAT = ${PARKEDAT} ${_PARKEDAT} ${__PARKEDAT});
  Set(PICKUP=${GLOBAL(PKP${HASH(res,Exten)})});

  if (${PICKUP}) {
   Set(GLOBAL(PKP${HASH(res,Exten)})=);
   Set(HASH(pkp)=${ODBC_EXTEN(${PICKUP})},${BIND});

   if ("${HASH(pkp,DND)}"!="1") {
    &InUse(${PICKUP});
   } else {
    DEVICE_STATE(Custom:${PICKUP})=BUSY;
   }
  }

  // Check for missed call here
  if ("${DIALSTATUS}"="NOANSWER"|"${DIALSTATUS}"="CANCEL") {
   if ("${HASH(res,MailTo)}"!="") {
      Set(missed="${CALLERID(num)} >> ${dnid}  ${STRFTIME(${EPOCH},,%H:%M:%S)}");
      System(/usr/local/sbin/mailer -f "PBX ${FILTER(0-9a-zA-Z\.\-,${SHELL(hostname)})}" -t '${HASH(res,MailTo)}' -s '${missed} не отвечен' -b '${missed}  is not answered' -charset UTF-8 );
    //Set(missed="Subject: ${CALLERID(num)} >> ${dnid}  ${STRFTIME(${EPOCH},,%d.%m.%Y %H:%M:%S)} HE OTBE4EH");
    //System(/bin/echo ${missed} | /usr/sbin/exim -bm -f 'pbx@ast1.miran.ru' -F 'PBX' -odf '${HASH(res,MailTo)}');
   }
  }

  StopMonitor();
//  Set(CDR(pbxserver)=${FILTER(0-9a-zA-Z\.\-,${SHELL(hostname)})});
  Set(CDR(pbxserver)=${PBXSERVER});
  NoOp(maxx: адрес файла для записи ${mfile});
  NoOp(maxx: достаем контекст ${CONTEXT} и пытаемся передать его в событие);
//  System(/usr/local/sbin/wav2mp3 ${mfile});

//  &Event(hangupexten);

  &Event(hang,${CONTEXT});
  return;
 }//catch h

 catch _. {

//    NoOp(maxx: exten: begin exten macro);

  if ("${HASH(res,BIND)}"!="") {
   if ("${HASH(res,Exten):0:1}"="!") {  // Cut BIND from extension spec
    Set(ext=${HASH(res,Exten):1});
    Set(ext1=${ext});
   } else {
    Set(ext=${HASH(res,BIND)}+${HASH(res,Exten)});
    Set(ext1=${HASH(res,BIND)}*${HASH(res,Exten)});
   }
  } else {
   Set(ext=${HASH(res,Exten)});
   Set(ext1=${ext});
  }

  if ("${BLINDTRANSFER}"!="") goto transfer|${EXTEN}|1; // BLIND TRANSFER TRAP
  if ("${dnid}"="") goto transfer|${EXTEN}|1; // TRANSFER TRAP

  // Now evaluate Dial() features for both calling and callee ends
  if ("${HASH(ext,FeatureTransfer)}"="1"&"${transfer}"="") T=T; else T=;
  if ("${HASH(res,FeatureTransfer)}"="1"&"${master}"="") {
   local TR=1;
   T=${T}t;
   Set(DF=xferA#xferB#BL);
  }
  if ("${HASH(ext,FeaturePark)}"="1"&"${transfer}"="") K=K; else K=;
  if ("${HASH(res,FeaturePark)}"="1") K=${K}k;

//  R=r;
  if ("${HASH(res,MOH):0:1}"="!") Set(__R=m(${HASH(res,MOH):1}));  // Force MOH on dial


  // Check for target extension call limit
  if ("${HASH(res,RouteGroup)}"!="") {
   local count=${GROUP_COUNT(${HASH(res,RouteGroup)}@R)};
  } else {
   local count=${GROUP_COUNT(${ext}@I)}+${GROUP_COUNT(${ext}@O)};
  }
  // atxfer makes direct call while returning from non-answered dial
  // This hack is suitable only for 1-line extensions
  if (${count}=0) Set(LOCAL(count)=${FIELDQTY(CHANNELS(/${EXTEN}-[0-9a-zA-Z]+$), )});

  if (${HASH(res,CallLimit)}<-1) { // Dynamic limit
   HASH(res,CallLimit)=1+${QUEUE_WAITING_COUNT(${HASH(res,RouteGroup)})}/2;
  }
   NoOp(maxx: details of pre-monitor in exten: DATA=${DATA} cdr(x-record="${CDR(x-record)}) ACTION=${CUT(HASH(res,Action),\,,1)} nextaction ${NEXTACTION} context ${context} iax-in ${iax-in});


  // Line monitoring - in
  if ("${HASH(res,MonitorTo)}"!="") &SetMonitor(${HASH(res,MonitorTo)},${HASH(res,BIND)},${dnid},${CALLERID(num)},in);

  if ("${HASH(ext,BIND)}+${HASH(ext,Exten)}"!="${HASH(res,BIND)}+${HASH(res,Exten)}") {
   // Line monitoring - out
   if ("${HASH(ext,MonitorTo)}"!="") &SetMonitor(${HASH(ext,MonitorTo)},${HASH(ext,BIND)},${cid},${dnid},out);
  }

   // Line monitoring - in
//  if ("${HASH(res,MonitorTo)}"!="") &SetMonitor(${HASH(res,MonitorTo)},${HASH(res,BIND)},${dnid},${CALLERID(num)},in);


 //DumpChan();
//!!!веприкову и коузову на разбор имени на экране

  Set(didname=${SIPPEER(${ext},callerid_name)});
  Set(CONNECTEDLINE(name,i)=${didname});
  Set(CONNECTEDLINE(pres)=allowed);

    //DumpChan();
     SIPaddheader(X-RouteGroup: ${HASH(res,RouteGroup)});

  // Scheduled transfers
  if ("${HASH(res,TransferSchedule)}"!="")
   if ("${ODBC_SCHEDULE(${HASH(res,TransferSchedule)})}"!="1") local NotScheduled=1;

  if ("${HASH(res,TransferCall)}"="!"|("${NotScheduled}"=""&"${HASH(res,TransferCall)}"!=""&${REGEX("${FILTER(0-9a-zA-Z#,${HASH(res,TransferCall)})}" ${LoopTransfer})}=0)) { // Make unconditional transfer, prevent looping here!
   Set(__LoopTransfer=${LoopTransfer} ${HASH(res,TransferCall)});

   if (${count} < ${HASH(res,CallLimit)}) {
    Set(OUTBOUND_GROUP_ONCE=${ext}@I);
    if ("${HASH(res,RouteGroup)}"!="") Set(OUTBOUND_GROUP_ONCE=${HASH(res,RouteGroup)}@R);
    Dial(LOCAL/${dnid}-${HASH(res,TransferCall)}@out/n,${HASH(res,Timeout)},${R}fg);
   } else {
    Set(CDR(x-result)=17:BUSY:LIMIT:TransferCall);
    CELGenUserEvent(xresult,BUSY);
    Dial(LOCAL/17@drop);
   }
  } else { // All other logic before conditional transfers

   if ((${count} >= ${HASH(res,CallLimit)})|("${HASH(res,DND)}"="1"))
   {
    Set(CDR(x-result)=17:BUSY:LIMIT:DND=${HASH(res,DND)});
    CELGenUserEvent(xresult,BUSY);
    Dial(LOCAL/17@drop/n);
   } else {


    if (${LEN(${CDR(guid)})}=0) {
    Set(CDR(guid)=${ODBC_GUID(${BIND},${REDIRECT})});
    CELGenUserEvent(guid,${CDR(guid)});
    }
    Set(CDR(last_guid)=${ODBC_GUID(${BIND},${HASH(res,Exten)})});
    CELGenUserEvent(last_guid,${CDR(last_guid)});

   // Process call list attached, prevent looping here!
   if (("${HASH(res,CallList)}"!=""&${REGEX("${HASH(res,CallList)}" ${LoopCallList})}=0)|("${HASH(res,SpawnCalls)}"!=""&${REGEX("${HASH(res,Exten)}" ${LoopSpawnCalls})}=0)) {
    if ("${HASH(res,CallList)}"!="") { // CallList
     Set(__LoopCallList=${LoopCallList} ${HASH(res,CallList)});
     Set(GROUP(I)=${ext});  // Prevent forking counters on CallList
     Set(HASH(list)=${ODBC_CALLLIST(${HASH(res,CallList)})});
     if (${HASH(list,Serial)}=1) { // Make serial call
      // Retrieve call list
      i=0;
      while (${i}>=0) {
       Set(HASH(call)=${ODBC_CALLS(${HASH(res,CallList)},${i})});
       if ("${HASH(call,Exten)}"="") Set(i=-1); else { // Call for this number
        i=${i}+1;
        if ("${HASH(call,Timeout)}"="") {
         Set(LOCAL(Timeout)=${HASH(list,Timeout)});
        } else {
         Set(LOCAL(Timeout)=${HASH(call,Timeout)});
        }
        // ???There is a better idea to process each exten as incoming-call???
        Dial(LOCAL/${dnid}-${HASH(call,Exten)}@out/n,${Timeout},${R}fg);
        if ("${DIALSTATUS}"="ANSWER") Set(i=-1); // Cancel list processing on first successfull call
       }
      }
     } else { // Make parallel call
      // Retrieve call list
      i=0;
      e=;
      while (${i}>=0) {
       Set(HASH(call)=${ODBC_CALLS(${HASH(res,CallList)},${i})});
       if ("${HASH(call,Exten)}"="") Set(i=-1); else { // Call for this number
        i=${i}+1;
        Set(e=${e}&LOCAL/${dnid}-${HASH(call,Exten)}@out/n);
       }
      }
      if ("${e:1}"!="") Dial(${e:1},${HASH(list,Timeout)},c${R}fg); // Spawn parallel calls
     }
    } else { // SpawnCalls
     Set(__LoopSpawnCalls=${LoopSpawnCalls} ${HASH(res,Exten)});
     Set(LOCAL(calls)=${HASH(res,SpawnCalls)});
     Set(_SPAWN=${HASH(res,Exten)});

     if (${REGEX("^:.*:$" ${CUT(calls,\,,1)})}=1) { // control sequence :[PSR][ !>]:
      Set(LOCAL(ctr)=${CUT(calls,\,,1):1:-1});
      NoOp(maxx: spawn: ${ctr});
      local first=2;
      if("${GLOBAL(RR_${dnid})}"!="") Set(LOCAL(pos)=${GLOBAL(RR_${dnid})}); else Set(LOCAL(pos)=${first});
     } else {
      local ctr=P;
      local first=1;
     }

     local rt=;
     for (LOCAL(i)=${first}; ${i}<=${FIELDQTY(calls,\,)}; LOCAL(i)=${i}+1) {
      if ("${ctr:0:1}"="P") {
       Set(LOCAL(rt)=${rt}&LOCAL/${ctr:1:2}${CUT(calls,\,,${i})}@spawn/n);
        NoOp(maxx: spawn: ${rt});
      } else {
      if ("${ctr:0:1}"="R") { // RoundRobin
       local pos=${pos}+1;
       if (${pos}>${FIELDQTY(Calls,\,)}) Set(LOCAL(pos)=${first});
       Set(GLOBAL(RR_${dnid})=${pos});
      } else Set(LOCAL(pos)=${i});

       Set(LOCAL(Timeout)=${HASH(res,Timeout)});
       Set(LOCAL(call)=${CUT(calls,\,,${pos})});
       if ("${CUT(call,:,2)}"!="") {
        Set(LOCAL(Timeout)=${CUT(call,:,2)});
        Set(LOCAL(call)=${CUT(call,:,1)});
       }

    //DumpChan();
       Dial(LOCAL/${dnid}-${ctr:1:2}${call}@out/n,${Timeout},${R}fg);
       if ("${DIALSTATUS}"="ANSWER") break; // Cancel list processing on first successfull call
      }
     }

     if ("${ctr:0:1}"="P") Dial(${rt:1},${HASH(res,Timeout)},${R}fg); // Spawn parallel calls
//     return;  NO!!! Proceed with DIALSTATUS
    }//SpawnCalls
   } else { // Simply call the extension
//   SetCallerPres(prohib);
//    Set(__PICKUPMARK=exten); The 1.6.2 "magic pickup" seems to be too buggy!!! 1.6.12 just patched
    Set(CDR(userfield)=${uniqueid}>${leg1}>${leg2}>${HASH(res,Exten)});
    Set(CHANNEL(amaflags)=billing);

    if("${HASH(res,Delay)}"!=""&&"${HASH(res,Delay)}">0) {
     Set(LOCAL(last)=${ODBC_LAST_ANSWERED(${HASH(res,Exten)},${BIND})});  // Pretty time bomb
     if("${last}"="") Set(LOCAL(last)=${HASH(res,Delay)});
     if (${last}>=${HASH(res,Delay)}) local PASS=1;
    } else local PASS=1;

    if("${PASS}"="1") {
     Set(OUTBOUND_GROUP_ONCE=${ext}@I);
     if ("${HASH(res,RouteGroup)}"!="") Set(OUTBOUND_GROUP_ONCE=${HASH(res,RouteGroup)}@R);

     DEVICE_STATE(Custom:${ext1})=RINGING;
     __ringing = 1;

//     SIPaddheader(Alert-Info: normal);
     Set(_PICKUPMARK=${ext1});

     // Old-spec dongle
     Set(LOCAL(Type)=${HASH(res,Type)});
     if ("${Type}"="SIP") Set(LOCAL(Type)=SIP/);
     if ("${Type}"="IAX2") Set(LOCAL(Type)=IAX2/);
     if ("${Type}"="LOCAL") Set(LOCAL(Type)=LOCAL/);
     Set(CDR(x-spec)=${Type});

     if ("${Type}"!="SIP/"&"${Type}"!="IAX2/") {
      local NoCheck=1;
     }

     if ("${ANNOUNCE}${ANNOUNCE_CALLED}"!="") {  // Playback announcements to calling|called party
      Set(__CALLING_CHANNEL=${CHANNEL});
      Set(A=G(announce^a^1));
      Set(_ARG1=${ext}); // Old style connection hack
      Set(_ARG2=${DF});
      Set(_ARG3=${HASH(res,MOH)});
      Set(_ARG4=${TR});
     } else A=;

     if ("${NoCheck}"="1"|${REGEX("^(OK|Unmonitored)|^$" ${SIPPEER(${ext},status)}${IAXPEER(${ext},status)})}=1) {
      Set(CDR(x-tag)=~EXTEN~);
      Set(CDR(x-cid)=${cid});
      Set(CDR(x-did)=${dnid});
      Set(CDR(x-dialed)=${ext});

      // Channel gains GainTX=10,GainRX=0
      NoOp(GainTX=${GainTX},GainRX=${GainRX});

      Set(GROUP(LegA)=${UNIQUEID}); // Channel hook
      if ("${NO_TRANSFER}"="1") Set(HASH(res,Timeout)=);

     if ("${HASH(res,MOH)}"!="") {
        Set(CHANNEL(musicclass)=${HASH(res,MOH)});
    }

//      NoOp(maxx:exten:230 num ${CALLERID(num)} name ${CALLERID(name)} );
        if ("${SIPPEER(${ext},status):0:2}"!="OK") {
            NoOp(maxx:exten: straight call, sip peer is not ok, refresh it with sh command);
            System(/usr/sbin/asterisk -rx 'sip show peer ${ext} load');
        };
      &Event(dialexten,${CONTEXT});
      Dial(${Type}${ext}${DialSuffix},${HASH(res,Timeout)},${T}${K}${R}${A}fgM(mmm^${ext1}^${DF}^${HASH(res,MOH)}^${TR}));

// severin      2022 10 04 try to correct queue statistic

    //  if ("${DIALSTATUS}"="BUSY") Set(DIALSTATUS=DND);  // implying valid CallLimit

      Set(CDR(x-result)=${HANGUPCAUSE}:${DIALSTATUS});
      CELGenUserEvent(xresult,${DIALSTATUS});
      if ("${CHANNEL(channeltype)}"="Local"&"${DIALSTATUS}"="CHANUNAVAIL") {
       // Local channel can't return "CHANUNAVAIL"
       Set(CDR(x-result)=27:CHANUNAVAIL);  // destination out of order
       CELGenUserEvent(xresult,CHANUNAVAIL);
       Dial(LOCAL/27@drop);
      }
     } else {
      Set(CDR(x-result)=27:CHANUNAVAIL);  // destination out of order
      CELGenUserEvent(xresult,CHANUNAVAIL);
      Dial(LOCAL/27@drop);
     }
    } else {
     DEVICE_STATE(Custom:${ext1})=BUSY;
     Set(CDR(x-result)=17:BUSY:Delay=${HASH(res,Delay)});
     CELGenUserEvent(xresult,BUSY);
     Dial(LOCAL/17@drop);
//     Set(DIALSTATUS=BUSY);
//     Set(HANGUPCAUSE=17);
    }
   }
  } // if (${max_calls} > ${HASH(res,CallLimit)})

  // Now, evaluate for conditional transfers upon the Dial() result...
  NoOp(DIALSTATUS = "${DIALSTATUS}");

  } // !!! if ("${HASH(res,TransferCall)}"!="") { // Make unconditional transfer

  // !!!CROSS-PBX SEARCH!!!
  if("${DIALSTATUS}"="CHANUNAVAIL"|"${DIALSTATUS}"="CONGESTION") {
   if ("${HASH(res,RouteTag)}"!="") {
    Set(TAG=${HASH(res,RouteTag)});  // Special tag for such routing
    &RouteCall(${HASH(res,Exten)},1);
   }
  }

  if ("${IN_QUEUE}"="1"&"${DIALSTATUS}"!="ANSWER"&"${DIALSTATUS}"!="NOANSWER") { // Don't spawn dumb cdr's on BUSY|FAIL
   NoCDR();
  }
  if ("${NO_TRANSFER}"="1") { // Avoid any transfers in such case
   goto ${h}|1;
  }

  // Now, evaluate for conditional transfers upon the Dial() result...
  if ("${DIALSTATUS}"="NOANSWER" | "${DIALSTATUS}"="CANCEL" | "${DIALSTATUS}"="CHANUNAVAIL" | "${DIALSTATUS}"="CONGESTION") {
   NoOp(***** = *${HASH(res,TransferOnTimeout)}*${LoopTransfer}*);
   if ("${HASH(res,TransferOnTimeout)}"!="" & ${REGEX("${FILTER(0-9a-zA-Z#\!,${HASH(res,TransferOnTimeout)})}" ${LoopTransfer})}=0) { // Make timeout-based transfer, prevent looping here!
    Set(__LoopTransfer=${LoopTransfer} ${HASH(res,TransferOnTimeout)});
    &InUse(${ext});

    Dial(LOCAL/${dnid}-${HASH(res,TransferOnTimeout)}@out/n,,${R}fg); // Instead of goto statement, for prevent macro() logic
   }
  } else {
  if ("${DIALSTATUS}"="BUSY"|"${DIALSTATUS}"="DND") {
   if ("${HASH(res,DND)}"="1") {
    DEVICE_STATE(Custom:${ext1})=BUSY;
    Playback(do-not-disturb);
   } else {
    if ("${ringing}"="1") &InUse(${ext});
   }

   if ("${HASH(res,TransferOnBusy)}"!="" & ${REGEX("${FILTER(0-9a-zA-Z#,${HASH(res,TransferOnBusy)})}" ${LoopTransfer})}=0) { // Make busy transfer, prevent looping here!
    Set(__LoopTransfer=${LoopTransfer} ${HASH(res,TransferOnBusy)});

    Dial(LOCAL/${dnid}-${HASH(res,TransferOnBusy)}@out/n,,${R}fg); // Instead of goto statement, for prevent macro() logic
   } else { // Try auto-redial, if enabled
    if ("${HASH(ext,AutoDial)}"="1") {
    NoOp(auto_dial);
     Read(num,auto_dial,1,,,3);
     if ("${num}"="1") {
      Set(ODBC_AUTO_DIAL(${cid})=${dnid}); // Set auto-dial
      Playback(auto_dial_enabled);
     } else {
      Set(ODBC_AUTO_DIAL(${cid})=); // Drop auto-dial
     }
    }
   }
  }
  }
  goto ${h}|1;
 } // catch _.

 return;
} // macro exten(res)

context macro-mmm { // Such fucking sintaxis due to ael bug in calling M() dial macro!!!

// Note: "LOCAL" statement don't work in inside macro
 s => {


  Set(_PARENT=${ARG1});
  Set(CHANNEL(language)=${DEFAULT_LANG});
  //NoOp(maxx: context macro-mmm ${DYNAMIC_FEATURES=});
  //NoOp(maxx: context macro-mmm DYNAMIC_FEATURES=${ARG2});
  Set(DYNAMIC_FEATURES=${ARG2});

    Set(_inuse_origin=mmm);
  if ("${ARG3}"!="") {
   Set(CHANNEL(musicclass)=${ARG3});
  }

  Set(_ALLOW_TRANSFER=${ARG4});

  callee=${ARG1};  // determite wether the channel is a callee leg

  Set(ch=${CUT(CHANNEL,-,1)});
  Set(ch=${CUT(ch,/,2)});
//  NoOp(PICKUP = ${ARG1} ${ch});

//  Set(PICKUP=${SHARED(PICKUP)});
//  if (${PICKUP}) {
  if ("${ARG1}"!="${ch}") {
    NoOp(maxx: mmm - inuse-parent);
   &InUse(${PARENT});
//   Set(GROUP(I)=${ch}); // "group show channels"

   if ("${GLOBAL(PKP${ARG1})}"="") { // Avoid duplication
    Set(GLOBAL(PKP${ARG1})=${ch});

    Set(HASH(pkp)=${ODBC_EXTEN(${ch})},${BIND});
    count=${GROUP_COUNT(${ch}@I)}+${GROUP_COUNT(${ch}@O)};

    Set(ODBC_LINE_STATUS(${HASH(pkp,Exten)},${BIND})=ANSWER);

    if (("${HASH(pkp,DND)}"!="1") & (${count}<0${HASH(pkp,CallLimit)})) {
     DEVICE_STATE(Custom:${ch})=INUSE;
    } else {
     DEVICE_STATE(Custom:${ch})=BUSY;
    }
    &InUse(${ARG1});

   }
  } else {
   Set(HASH(ext)=${ODBC_EXTEN(${ARG1})},${BIND});
   count=${GROUP_COUNT(${HASH(ext,Exten)}@I)}+${GROUP_COUNT(${HASH(ext,Exten)}@O)};

   Set(ODBC_LINE_STATUS(${HASH(ext,Exten)},${BIND})=ANSWER);

   if (("${HASH(ext,DND)}"!="1") & (${count}<0${HASH(ext,CallLimit)})) {
    DEVICE_STATE(Custom:${ARG1})=INUSE;
   } else {
    DEVICE_STATE(Custom:${ARG1})=BUSY;
   }
  }

  if ("${SEND_MESSAGE}"!="") {
   SendText(${SEND_MESSAGE});
  }

  Set(_LegB=1); // For make transfer in correct mode

  Set(GROUP(LegB)=${UNIQUEID}); // Channel hook
  NoOp(maxx: connectexten);

    //DumpChan();

    NoOp(maxx:mmm mfile ${mfile});
    //Set(__mfile=${mfile});

  &Event(connectexten,${CONTEXT});
//  return;
 }
} // macro mmm(res)

context spawn { // Spawn call with optional timeout before
 h => {
//  Set(CDR(pbxserver)=${FILTER(0-9a-zA-Z\.\-,${SHELL(hostname)})});
  Set(CDR(pbxserver)=${PBXSERVER});
  &Event(hang,${CONTEXT});
  Hangup();
 }
 _. => {
  Set(CDR(x-domain)=${BIND});
  Set(CHANNEL(userfield)=${BIND});

  Set(ext=${CUT(EXTEN,:,1)});
  Set(t=${CUT(EXTEN,:,2)});
  if ("${t}"!="") {
   Wait(${t});
  }
//  Set(CDR(pbxserver)=${FILTER(0-9a-zA-Z\.\-,${SHELL(hostname)})});
  Set(CDR(pbxserver)=${PBXSERVER});
  Set(DATA=${DATA},CONTEXT=spawn;SPAWN=${ext});
  Set(CDR(x-data)={${DATA:1}});

  Dial(LOCAL/${SPAWN}-${ext}@out/n,,${R}fg);
 }
}
context announce { // Do announcements on call bridging
 h => {
  h=h;
  if ("${calling}"="") goto exten,${h},1;
 }

 a => {
  goto calling|1;
  goto called|1;
 }

 calling => {
  calling=1;
  if ("${ANNOUNCE}"!="") Playback(${ANNOUNCE});
  Set(SHARED(ANNOUNCE_DONE)=1);
loop:
  Wait(86400);
  goto loop;
 }

 called => {
  if ("${ANNOUNCE_CALLED}"!="") Playback(${ANNOUNCE_CALLED});
  if ("${ANNOUNCE}"!=""){
   while ("${SHARED(ANNOUNCE_DONE,${CALLING_CHANNEL})}"="") MusicOnHold(,1);
   Playback(beep);
  }
  Set(mmm=macro-mmm);
  &${mmm}(${ARG1},${ARG2},${ARG3},${ARG4});
  Bridge(${CALLING_CHANNEL});
 }
}



context ConfInvite {
s=> {

Set(__DYNAMIC_FEATURES=conf_invite_ok#conf_invite_cancel);

NoOp(context ConfInvite  ${ARG1});
//Background(confbridge-begin-glorious-a);
Background(invite-conf);

Read(invite_num,,5);
NoOp(!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Diim context ConfInvite  ${invite_num},  BP ${BRIDGEPEER},ARG1: ${ARG1}, CN ${CHANNEL}, CNUM ${CALLERID(num)}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!);


Set(ConfName=${ARG1});
Set(CBArg=${ARG1},,5);
//Set(var1=6666);

NoOp(DEBUG, передаем номер очереди ConfName ${ConfName}, ${BIND}, CBArg ${CBArg});
//Log(DEBUG, шта бля);

//GoSub(ConfInvite2^${ARG1}^${invite_num}^${CHANNEL});
//Originate(SIP/78123313568+${invite_num},exten,sip,355,1);

//Originate(SIP/${BIND}+${invite_num},app,ConfBridge,${ARG1},,5,ncv(var1=6666);  //Рабочий.
System(/usr/local/sbin/conf-ivite-call ${BIND} ${ConfName} ${invite_num} ${CBArg} );

//Originate(SIP/${BIND}+${invite_num},app,ConfBridge,${ARG1},,20,nc));

Log(DEBUG, ConfInvite шг 2 ${SYSTEMSTATUS});

 }
}

context ConfInvCall {
s=> {
    Set(__DYNAMIC_FEATURES=conf_invite_ok#conf_invite_cancel);

NoOp(context ConfInvCall  ${ARG1});

//Background(confbridge-conf-begin);
Background(invite-conf);
Read(invite_num,,3);


Log(DEBUG, Diim context ConfInvCall  ${invite_num},  BP ${BRIDGEPEER}, ARG1: ${ARG1}, CN ${CHANNEL}, CID ${CALLERID(num)});

Set(CHAN_num=${CALLERID(num)});
Set(ConfName=${ARG1});

Log(DEBUG, передаем номер очереди ConfName ${ConfName}, ${BIND},${invite_num}, ${CHAN_num});

System(/usr/local/sbin/conf-call ${BIND} ${ConfName} ${invite_num} ${CALLERID(num)});

Log(DEBUG, ConfInvCalle шг 2 ${SYSTEMSTATUS});

  }
}
