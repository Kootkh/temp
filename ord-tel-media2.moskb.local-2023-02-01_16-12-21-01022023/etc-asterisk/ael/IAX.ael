// DialPlan processing contexts
// !!! OLD routing scheme: cross-PBX calls
context iax {
// iax calls must come in here
 h => {
//  Set(CDR(pbxserver)=${FILTER(0-9a-zA-Z\.\-,${SHELL(hostname)})});
  Set(CDR(pbxserver)=${PBXSERVER});
  goto i|1;
 }

 i => {
  NoOp(QOS = "${RTPAUDIOQOS}");
  NoOp(CHANNELS iax-call hang = ${CHANNEL} :: ${uniqueid}>${leg1}>${leg2}>${dnid});
  Set(CDR(x-result)=${HANGUPCAUSE}:${DIALSTATUS});
  CELGenUserEvent(xresult,${DIALSTATUS});
  NoOp(maxx: адрес файла для записи ${mfile});
//  StopMonitor();
//  System(/usr/local/sbin/wav2mp3 ${mfile});
//  Set(CDR(pbxserver)=${FILTER(0-9a-zA-Z\.\-,${SHELL(hostname)})});
  Set(CDR(pbxserver)=${PBXSERVER});
  &Event(hang,${CONTEXT});

  Hangup(${HANGUPCAUSE});
  //DumpChan();
 }
 _. => { // It seems that such calls must be routed out with no restrictions...
  NoOp(CHANNELS iax-call start = ${CHANNEL} :: ${uniqueid}>${leg1}>${leg2}>${dnid});
  Log(DEBUG, CHANNELS iax-call start = ${CHANNEL} :: ${uniqueid}>${leg1}>${leg2}>${dnid} BIND - ${BIND});
    //DumpChan();

    //if ("${mfile}"="") {
        //Set(__mfile=); //for MonitorTo use
    //}

  Set(__dnid=${EXTEN}); // CALLERID(dnid) is empty while transferring through iax for some reason!
  Set(__INHERIT_CONTEXT=iax);
  Set(__iaxoriginid=${CHANNEL(UniqueID)});
  &call-entry(${CONTEXT}); // Note that this is not "incoming" or "outgoing" call
  // Leg definitions must be stored overall call processing!
  if ("${leg1}"="") Set(__leg1=${CALLERID(num)});
  if ("${leg2}"="") Set(__leg2=${CALLERID(dnid)}); // In most cases, must be ${EXTEN} in entry context
  if ("${leg2}"="") Set(__leg2=${EXTEN}); // In most cases, must be ${EXTEN} in entry context
  if ("${uniqueid}"="") Set(__uniqueid=${CDR(uniqueid)});

  Set(CHANNEL(accountcode)=${leg2});
  Set(CDR(userfield)=${uniqueid}>${leg1}>${leg2}>ROOT);
  Set(CHANNEL(amaflags)=billing);
  Set(CDR(pbxserver)=${PBXSERVER});

  // So, I'm just trying to put such call into suitable route
  Set(_ALLOW_TRANSFER=${ALLOW_TRANSFER});

  Set(HASH(res)=${ODBC_CALLBACK(${dnid},${cid})}); // Has local alias been dialed?
  if ("${HASH(res,Exten)}"!="") {
   &call-back(${res});
   goto i|1;
  }

  Set(HASH(res)=${ODBC_LEVEL_E(${dnid},${cid},${Aliased},${BIND})});
//  Set(DATA=${DATA},CONTEXT=iax;TAG=${TAG};ACTION=${CUT(HASH(res,Action),\,,1)});

      if ("${CUT(HASH(res,Action),\,,1)}"="exten") {
        NoOp(maxx: OutgoingCall: filling data: channel is not local,action is exten);
//        Set(DATA=${DATA},CONTEXT=incoming-call;TAG=${TAG};ACTION=${CUT(HASH(res,Action),\,,1)};Exten=${dnid};Guid=${ODBC_GUID(${BIND},${dnid})});
        Set(DATA=${DATA},CONTEXT=incoming-call;TAG=${TAG};ACTION=${CUT(HASH(res,Action),\,,1)};Exten=${dnid});
    } else {
    NoOp(maxx: OutgoingCall: filling data: channel is not local, action is NOT exten);
    Set(DATA=${DATA},CONTEXT=outgoing-call;TAG=${TAG};ACTION=${CUT(HASH(res,Action),\,,1)});
    }



  if ("${CUT(CHANNEL,/,1)}"!="Local") {
   if ("${CUT(HASH(res,Action),\,,1)}"="i") {
    System(/usr/local/sbin/mailer -f "SSS <`/bin/hostname`>" -t 'voice@obit.ru' -s '${FILTER(0-9a-zA-Z\.\-,${SHELL(hostname)})}  INVALID IAX!!! TAG=${TAG}@${CHANNEL}' -b '${HASH(res,Note)} ** ${uniqueid}>${leg1}>${leg2} ** ODBC_GET_ACTION(${dnid},${cid},${Aliased},${BIND}) >> ${HASH(res,Action)}' -charset UTF-8);
   }
  } else {
   if ("${CUT(HASH(res,Action),\,,1)}"="i"&"${HASH(res,Note)}"!="restrict:-1") {
    System(/usr/local/sbin/mailer -f "SSS <`/bin/hostname`>" -t 'voice@obit.ru' -s '${FILTER(0-9a-zA-Z\.\-,${SHELL(hostname)})}  INVALID IAX!!! TAG=local' -b '${HASH(res,Note)} ** ${uniqueid}>${leg1}>${leg2} ** ODBC_GET_ACTION(${dnid},${cid},${Aliased},${BIND}) >> ${HASH(res,Action)}' -charset UTF-8);
   }
  }

  if ("${CUT(HASHKEYS(res),\,,1)}"="") {
   System(/usr/local/sbin/mailer -f "SSS <`/bin/hostname`>" -t 'voice@obit.ru' -s '${FILTER(0-9a-zA-Z\.\-,${SHELL(hostname)})}  IAX BUG!!! TAG=${TAG}@${CHANNEL}' -b '${uniqueid}>${leg1}>${leg2}' -charset UTF-8);
  }

  Set(CDR(x-data)={${DATA:1}});

//  Gosub(${ODBC_GET_ACTION(${dnid},${cid},${Aliased},${BIND})});
  NoOp(${leg1}>>${leg2} FUNCTION iax(${HASH(res,Note)},${TAG},${CHANNEL}));

  Gosub(${HASH(res,Action)});
  goto i|1;
 }

} // context iax
